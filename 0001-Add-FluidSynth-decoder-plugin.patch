From 3774dd2b43104772baba52afc97e15b539461995 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Joan=20Bruguera=20Mic=C3=B3?= <joanbrugueram@gmail.com>
Date: Sat, 3 Jun 2023 21:42:07 +0000
Subject: [PATCH] Add FluidSynth decoder plugin

---
 README                                   |   1 +
 THANKS                                   |   3 +
 TODO                                     |   2 -
 config.example.in                        |   4 +
 decoder_plugins/Makefile.am              |   4 +
 decoder_plugins/decoders.m4              |   1 +
 decoder_plugins/fluidsynth/.clang-format |   7 +
 decoder_plugins/fluidsynth/Makefile.am   |  10 +
 decoder_plugins/fluidsynth/fluidsynth.c  | 324 +++++++++++++++++++++++
 decoder_plugins/fluidsynth/fluidsynth.m4 |  34 +++
 options.c                                |   3 +
 tools/md5check.sh                        |   2 +-
 12 files changed, 392 insertions(+), 3 deletions(-)
 create mode 100644 decoder_plugins/fluidsynth/.clang-format
 create mode 100644 decoder_plugins/fluidsynth/Makefile.am
 create mode 100644 decoder_plugins/fluidsynth/fluidsynth.c
 create mode 100644 decoder_plugins/fluidsynth/fluidsynth.m4

diff --git a/README b/README
index 15469f5..1f19668 100644
--- a/README
+++ b/README
@@ -79,6 +79,7 @@ provide the libraries needed to support them:
           libid3tag (http://www.underbit.com/products/mad/)
   - FLAC - libFLAC version 1.1 (http://flac.sourceforge.net/)
   - MIDI - libtimidity version 0.1 (http://timidity.sourceforge.net/)
+  - MIDI - FluidSynth version 2.0.0 (https://www.fluidsynth.org/)
   - modplug - libmodplug version 0.7 (http://modplug-xmms.sourceforge.net/)
   - MP3 - libmad with libid3tag (ftp://ftp.mars.org/pub/mpeg/)
   - Musepack (mpc) - libmpc (http://www.musepack.net/), and
diff --git a/THANKS b/THANKS
index c661625..327109c 100644
--- a/THANKS
+++ b/THANKS
@@ -14,6 +14,9 @@ Daniel T. Borelli:
 	* Assisted with testing.
 	* Provided basis for fixing foreground mode unreaped children.
 
+Joan Bruguera:
+	* Added FluidSynth decoder for MIDI.
+
 Morten Grunnet Buhl:
 	* Provided Yellow/Red theme.
 
diff --git a/TODO b/TODO
index 5a40d61..0275efe 100644
--- a/TODO
+++ b/TODO
@@ -171,8 +171,6 @@ Future Wishlist (items marked with $ are bigger changes requiring more time):
 * posix_fadvise() with POSIX_FADV_WILLNEED instead of the input buffer thread
   for files.
 * Recording played sound to a file.
-* Upgrade TiMidity decoder plug-in to TiMidity++.  This would add support
-  for soundfonts (.sf2) which are now more common.
 
 
 Maybe Never:
diff --git a/config.example.in b/config.example.in
index 9e3b4be..b8d4297 100644
--- a/config.example.in
+++ b/config.example.in
@@ -623,6 +623,10 @@
 # Otherwise set it to the name of a specific file.
 #TiMidity_Config =
 
+# Self-describing FluidSynth audio characteristic options.
+#FluidSynth_SoundFont = /usr/share/soundfonts/default.sf2
+#FluidSynth_Rate = 44100            # Between 8000 and 96000
+
 # Self-describing SidPlay2 audio characteristic options.
 #SidPlay2_DefaultSongLength = 180   # If not in database (in seconds)
 #SidPlay2_MinimumSongLength = 0     # Play at least n (in seconds)
diff --git a/decoder_plugins/Makefile.am b/decoder_plugins/Makefile.am
index 32a6376..ecfd65d 100644
--- a/decoder_plugins/Makefile.am
+++ b/decoder_plugins/Makefile.am
@@ -36,6 +36,10 @@ if BUILD_timidity
     SUBDIRS += timidity
 endif
 
+if BUILD_fluidsynth
+    SUBDIRS += fluidsynth
+endif
+
 if BUILD_sidplay2
     SUBDIRS += sidplay2
 endif
diff --git a/decoder_plugins/decoders.m4 b/decoder_plugins/decoders.m4
index 77bc2b3..d977785 100644
--- a/decoder_plugins/decoders.m4
+++ b/decoder_plugins/decoders.m4
@@ -24,6 +24,7 @@ m4_include(decoder_plugins/sidplay2/sidplay2.m4)
 m4_include(decoder_plugins/sndfile/sndfile.m4)
 m4_include(decoder_plugins/speex/speex.m4)
 m4_include(decoder_plugins/timidity/timidity.m4)
+m4_include(decoder_plugins/fluidsynth/fluidsynth.m4)
 m4_include(decoder_plugins/vorbis/vorbis.m4)
 m4_include(decoder_plugins/wavpack/wavpack.m4)
 
diff --git a/decoder_plugins/fluidsynth/.clang-format b/decoder_plugins/fluidsynth/.clang-format
new file mode 100644
index 0000000..a8536d9
--- /dev/null
+++ b/decoder_plugins/fluidsynth/.clang-format
@@ -0,0 +1,7 @@
+BasedOnStyle: LLVM
+IndentWidth: 8
+UseTab: Always
+ColumnLimit: 80
+SortIncludes: false
+BreakBeforeBraces: Allman
+AllowShortFunctionsOnASingleLine: None
diff --git a/decoder_plugins/fluidsynth/Makefile.am b/decoder_plugins/fluidsynth/Makefile.am
new file mode 100644
index 0000000..718809e
--- /dev/null
+++ b/decoder_plugins/fluidsynth/Makefile.am
@@ -0,0 +1,10 @@
+lib_LTLIBRARIES = libfluidsynth_decoder.la
+libdir = $(plugindir)/$(DECODER_PLUGIN_DIR)
+libfluidsynth_decoder_la_LDFLAGS = @PLUGIN_LDFLAGS@
+libfluidsynth_decoder_la_LIBADD = $(fluidsynth_LIBS)
+libfluidsynth_decoder_la_CFLAGS = $(fluidsynth_CFLAGS) -I$(top_srcdir)
+if HAVE_smf
+    libfluidsynth_decoder_la_LIBADD += $(smf_LIBS)
+    libfluidsynth_decoder_la_CFLAGS += $(smf_CFLAGS)
+endif
+libfluidsynth_decoder_la_SOURCES = fluidsynth.c
diff --git a/decoder_plugins/fluidsynth/fluidsynth.c b/decoder_plugins/fluidsynth/fluidsynth.c
new file mode 100644
index 0000000..674ba64
--- /dev/null
+++ b/decoder_plugins/fluidsynth/fluidsynth.c
@@ -0,0 +1,324 @@
+/*
+ * MOC - music on console
+ * Copyright (C) 2004 Damian Pietras <daper@daper.net>
+ *
+ * FluidSynth-plugin Copyright (C) 2023 Joan Bruguera <joanbrugueram@gmail.com>
+ * Based on libTiMidity-plugin, Copyright (C) 2007 Hendrik Iben <hiben@tzi.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <string.h>
+#include <assert.h>
+#include <fluidsynth.h>
+#ifdef HAVE_SMF
+#include <smf.h>
+#endif
+
+#define DEBUG
+
+#include "common.h"
+#include "io.h"
+#include "decoder.h"
+#include "log.h"
+#include "files.h"
+#include "options.h"
+
+struct fluidsynth_data
+{
+	fluid_synth_t *synth;
+	fluid_player_t *player;
+#ifdef HAVE_SMF
+	smf_t *smf;
+#endif
+	struct decoder_error error;
+};
+
+static const char *soundfont = NULL;
+static int rate = 44100;
+static fluid_settings_t *settings;
+
+static void free_fluidsynth_data(struct fluidsynth_data *data)
+{
+	if (data->player)
+	{
+		delete_fluid_player(data->player);
+		data->player = NULL;
+	}
+	if (data->synth)
+	{
+		delete_fluid_synth(data->synth);
+		data->synth = NULL;
+	}
+#ifdef HAVE_SMF
+	if (data->smf)
+	{
+		smf_delete(data->smf);
+		data->smf = NULL;
+	}
+#endif
+}
+
+static struct fluidsynth_data *make_fluidsynth_data(const char *file)
+{
+	struct fluidsynth_data *data =
+	    (struct fluidsynth_data *)xmalloc(sizeof(struct fluidsynth_data));
+	data->synth = NULL;
+	data->player = NULL;
+#ifdef HAVE_SMF
+	data->smf = NULL;
+#endif
+	decoder_error_init(&data->error);
+
+	data->synth = new_fluid_synth(settings);
+	if (data->synth == NULL)
+	{
+		decoder_error(&data->error, ERROR_FATAL, 0,
+			      "Failed to create the FluidSynth synth");
+		free_fluidsynth_data(data);
+		return data;
+	}
+	if (soundfont != NULL &&
+	    fluid_synth_sfload(data->synth, soundfont, 1) == FLUID_FAILED)
+	{
+		decoder_error(&data->error, ERROR_FATAL, 0,
+			      "Can't load soundfont: %s", soundfont);
+		free_fluidsynth_data(data);
+		return data;
+	}
+
+	data->player = new_fluid_player(data->synth);
+	if (data->player == NULL)
+	{
+		decoder_error(&data->error, ERROR_FATAL, 0,
+			      "Failed to create the FluidSynth player");
+		free_fluidsynth_data(data);
+		return data;
+	}
+
+	if (fluid_player_add(data->player, file) == FLUID_FAILED)
+	{
+		decoder_error(&data->error, ERROR_FATAL, 0,
+			      "Can't load midifile: %s", file);
+		free_fluidsynth_data(data);
+		return data;
+	}
+
+	if (fluid_player_play(data->player) == FLUID_FAILED)
+	{
+		decoder_error(&data->error, ERROR_FATAL, 0,
+			      "Can't play midifile: %s", file);
+		free_fluidsynth_data(data);
+		return data;
+	}
+
+#ifdef HAVE_SMF
+	data->smf = smf_load(file);
+	if (data->smf == NULL)
+	{
+		decoder_error(&data->error, ERROR_FATAL, 0,
+			      "Can't load midifile with libsmf: %s", file);
+		free_fluidsynth_data(data);
+		return data;
+	}
+#endif
+
+	return data;
+}
+
+static void *fluidsynth_open(const char *file)
+{
+	return make_fluidsynth_data(file);
+}
+
+static void fluidsynth_close(void *void_data)
+{
+	struct fluidsynth_data *data = (struct fluidsynth_data *)void_data;
+
+	free_fluidsynth_data(data);
+	decoder_error_clear(&data->error);
+	free(data);
+}
+
+static void fluidsynth_info(const char *file_name, struct file_tags *info,
+			    const int tags_sel)
+{
+#ifdef HAVE_SMF
+	smf_t *smf = smf_load(file_name);
+	if (smf == NULL)
+	{
+		return;
+	}
+
+	if (tags_sel & TAGS_TIME)
+	{
+		info->time = (int)smf_get_length_seconds(smf);
+		info->filled |= TAGS_TIME;
+	}
+
+	smf_delete(smf);
+#endif
+}
+
+static int fluidsynth_seek(void *void_data, int sec)
+{
+#ifdef HAVE_SMF
+	struct fluidsynth_data *data = (struct fluidsynth_data *)void_data;
+
+	assert(sec >= 0);
+
+	float sec_clamp = MIN(sec, smf_get_length_seconds(data->smf));
+	if (smf_seek_to_seconds(data->smf, sec_clamp) != 0)
+	{
+		return -1;
+	}
+
+	smf_event_t *event = smf_peek_next_event(data->smf);
+	if (fluid_player_seek(data->player, event->time_pulses) == FLUID_FAILED)
+	{
+		return -1;
+	}
+
+	return (int)event->time_seconds;
+#else
+	return -1;
+#endif
+}
+
+static int fluidsynth_decode(void *void_data, char *buf, int buf_len,
+			     struct sound_params *sound_params)
+{
+	struct fluidsynth_data *data = (struct fluidsynth_data *)void_data;
+
+	sound_params->channels = 2;
+	sound_params->rate = rate;
+	sound_params->fmt = SFMT_S16 | SFMT_LE;
+
+	if (fluid_player_get_status(data->player) != FLUID_PLAYER_PLAYING)
+	{
+		return 0;
+	}
+
+	if (fluid_synth_write_s16(data->synth,
+				  buf_len / (2 * sound_params->channels), buf,
+				  0, 2, buf, 1, 2) == FLUID_FAILED)
+	{
+		return 0;
+	}
+
+	return buf_len;
+}
+
+static int fluidsynth_get_bitrate(void *void_data ATTR_UNUSED)
+{
+	return -1;
+}
+
+static int fluidsynth_get_duration(void *void_data)
+{
+#ifdef HAVE_SMF
+	struct fluidsynth_data *data = (struct fluidsynth_data *)void_data;
+	return (int)smf_get_length_seconds(data->smf);
+#else
+	return -1;
+#endif
+}
+
+static void fluidsynth_get_name(const char *file ATTR_UNUSED, char buf[4])
+{
+	strcpy(buf, "MID");
+}
+
+static int fluidsynth_our_format_ext(const char *ext)
+{
+	return !strcasecmp(ext, "MID");
+}
+
+static int fluidsynth_our_format_mime(const char *mime)
+{
+	return !strcasecmp(mime, "audio/midi") ||
+	       !strncasecmp(mime, "audio/midi;", 10);
+}
+
+static void fluidsynth_get_error(void *prv_data, struct decoder_error *error)
+{
+	struct fluidsynth_data *data = (struct fluidsynth_data *)prv_data;
+
+	decoder_error_copy(error, &data->error);
+}
+
+static void fluidsynth_init()
+{
+	soundfont = options_get_str("FluidSynth_SoundFont");
+	rate = options_get_int("FluidSynth_Rate");
+
+	// Since we just decode into a buffer, we don't need audio drivers.
+	// And also avoid https://github.com/FluidSynth/fluidsynth/issues/218
+	static const char *EMPTY_AUDIO_DRIVERS[] = {NULL};
+	if (fluid_audio_driver_register(EMPTY_AUDIO_DRIVERS) == FLUID_FAILED)
+	{
+		fatal("FluidSynth: Failed to register empty audio drivers");
+	}
+
+	settings = new_fluid_settings();
+	if (settings == NULL)
+	{
+		fatal("FluidSynth: Failed to create settings");
+	}
+
+	if (fluid_settings_setnum(settings, "synth.sample-rate", rate) ==
+	    FLUID_FAILED)
+	{
+		fatal("FluidSynth: Failed to set the sample date");
+	}
+
+	if (soundfont == NULL)
+	{
+		char *default_soundfont;
+		if (fluid_settings_getstr_default(settings,
+					      "synth.default-soundfont",
+					      &default_soundfont) == FLUID_OK)
+		{
+			soundfont = default_soundfont;
+		}
+	}
+}
+
+static void fluidsynth_destroy()
+{
+	delete_fluid_settings(settings);
+	settings = NULL;
+}
+
+static struct decoder fluidsynth_decoder = {DECODER_API_VERSION,
+					    fluidsynth_init,
+					    fluidsynth_destroy,
+					    fluidsynth_open,
+					    NULL,
+					    NULL,
+					    fluidsynth_close,
+					    fluidsynth_decode,
+					    fluidsynth_seek,
+					    fluidsynth_info,
+					    fluidsynth_get_bitrate,
+					    fluidsynth_get_duration,
+					    fluidsynth_get_error,
+					    fluidsynth_our_format_ext,
+					    fluidsynth_our_format_mime,
+					    fluidsynth_get_name,
+					    NULL,
+					    NULL,
+					    NULL};
+
+struct decoder *plugin_init()
+{
+	return &fluidsynth_decoder;
+}
diff --git a/decoder_plugins/fluidsynth/fluidsynth.m4 b/decoder_plugins/fluidsynth/fluidsynth.m4
new file mode 100644
index 0000000..800bc5e
--- /dev/null
+++ b/decoder_plugins/fluidsynth/fluidsynth.m4
@@ -0,0 +1,34 @@
+dnl fluidsynth
+
+AC_ARG_WITH(fluidsynth, AS_HELP_STRING([--without-fluidsynth],
+                                       [Compile without FluidSynth]))
+
+if test "x$with_fluidsynth" != "xno"
+then
+	PKG_CHECK_MODULES(fluidsynth, fluidsynth >= 2.0.0,
+			   [AC_SUBST(fluidsynth_LIBS)
+			   AC_SUBST(fluidsynth_CFLAGS)
+			   want_fluidsynth="yes"
+			   DECODER_PLUGINS="$DECODER_PLUGINS fluidsynth"],
+			   [true])
+fi
+
+AM_CONDITIONAL([BUILD_fluidsynth], [test "$want_fluidsynth"])
+AC_CONFIG_FILES([decoder_plugins/fluidsynth/Makefile])
+
+dnl libsmf (optional: support for duration and seeking)
+
+AC_ARG_WITH(smf, AS_HELP_STRING([--without-smf],
+                                 [Compile without smf]))
+
+if test "x$with_smf" != "xno"
+then
+	PKG_CHECK_MODULES(smf, smf >= 1.3,
+			   [AC_SUBST(smf_LIBS)
+			   AC_SUBST(smf_CFLAGS)
+			   have_smf="yes"
+			   AC_DEFINE([HAVE_SMF], [1], [Define if you have smf.])],
+			   [true])
+fi
+
+AM_CONDITIONAL([HAVE_smf], [test "$have_smf"])
diff --git a/options.c b/options.c
index c348b2b..acb32b8 100644
--- a/options.c
+++ b/options.c
@@ -725,6 +725,9 @@ void options_init ()
 	add_int  ("TiMidity_Volume", 100, CHECK_RANGE(1), 0, 800);
 	add_str  ("TiMidity_Config", NULL, CHECK_NONE);
 
+	add_str  ("FluidSynth_SoundFont", NULL, CHECK_NONE);
+	add_int  ("FluidSynth_Rate", 44100, CHECK_RANGE(1), 8000, 96000);
+
 	add_int  ("SidPlay2_DefaultSongLength", 180,
 	                 CHECK_RANGE(1), 0, INT_MAX);
 	add_int  ("SidPlay2_MinimumSongLength", 0,
diff --git a/tools/md5check.sh b/tools/md5check.sh
index 870cf25..ec97802 100755
--- a/tools/md5check.sh
+++ b/tools/md5check.sh
@@ -237,7 +237,7 @@ do
       $DEC
       SUM2=$(echo "$SUM2" | cut -f1 -d' ')
       ;;
-  modplug|musepack|sidplay2|timidity|tremor|wavpack)
+  modplug|musepack|sidplay2|timidity|fluidsynth|tremor|wavpack)
       $IGNORE && continue
       [[ "${UNSUPPORTED[$DEC]}" ]] || {
         echo -e "*** Decoder not yet supported: $DEC\n" > /dev/stderr
-- 
2.41.0

